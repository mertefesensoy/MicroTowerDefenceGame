// ProgressionTypes.swift
// Core types for meta-progression (XP, Unlocks, Persistent State)

import Foundation

/// Persistent player profile
public struct ProgressionProfile: Codable, Equatable, Sendable {
    public var xp: Int
    public var level: Int
    public var unlocks: Set<String>
    
    public init(xp: Int = 0, level: Int = 1, unlocks: Set<String> = []) {
        self.xp = xp
        self.level = level
        self.unlocks = unlocks
    }
    
    /// Normalize unlocks to match current level
    /// Call this after loading from disk to ensure rule changes/missing data don't leave gaps
    public mutating func reconcileUnlocks(rules: ProgressionRules) {
        // Collect all unlocks implied by current level
        for lv in 1...level {
            let impliedUnlocks = rules.unlocksForLevel(lv)
            for id in impliedUnlocks {
                unlocks.insert(id)
            }
        }
    }
}

/// Summary of a completed run for progression calculation
public struct RunSummary: Codable, Equatable, Sendable {
    public let runSeed: UInt64
    public let wavesCleared: Int
    public let ticksSurvived: Int
    public let coinsEarned: Int
    public let enemiesDefeated: Int
    public let didWin: Bool
    public let relicIDsChosen: [String]
    
    public init(runSeed: UInt64, wavesCleared: Int, ticksSurvived: Int, coinsEarned: Int, enemiesDefeated: Int, didWin: Bool, relicIDsChosen: [String]) {
        self.runSeed = runSeed
        self.wavesCleared = wavesCleared
        self.ticksSurvived = ticksSurvived
        self.coinsEarned = coinsEarned
        self.enemiesDefeated = enemiesDefeated
        self.didWin = didWin
        self.relicIDsChosen = relicIDsChosen
    }
}

/// Events generated by progression updates
public enum ProgressionEvent: Equatable, Sendable {
    case xpGained(amount: Int)
    case leveledUp(from: Int, to: Int)
    case unlocked(id: String)
}

// MARK: - Persistence DTOs

/// Metadata about the last completed run
public struct LastRunMetadata: Codable, Equatable, Sendable {
    public var runSeed: UInt64
    public var didWin: Bool
    public var wavesCleared: Int
    public var ticksSurvived: Int

    public init(runSeed: UInt64, didWin: Bool, wavesCleared: Int, ticksSurvived: Int) {
        self.runSeed = runSeed
        self.didWin = didWin
        self.wavesCleared = wavesCleared
        self.ticksSurvived = ticksSurvived
    }
}

/// Versioned save file envelope for persistence
/// Wraps ProgressionProfile with metadata to support future migrations
public struct ProgressionSaveFile: Codable, Equatable, Sendable {
    public static let currentSchemaVersion = 1

    public var schemaVersion: Int
    public var savedAt: Date
    public var profile: ProgressionProfile

    /// Optional metadata about the last run (for debugging/UX)
    public var lastRun: LastRunMetadata?

    public init(
        schemaVersion: Int = Self.currentSchemaVersion,
        savedAt: Date = Date(),
        profile: ProgressionProfile,
        lastRun: LastRunMetadata? = nil
    ) {
        self.schemaVersion = schemaVersion
        self.savedAt = savedAt
        self.profile = profile
        self.lastRun = lastRun
    }
}

// MARK: - Progression Rules
public struct ProgressionRules: Sendable {
    public init() {}
    
    // XP Formula
    public func xpForRun(_ run: RunSummary) -> Int {
        var xp = 0
        xp += run.wavesCleared * 50
        xp += run.enemiesDefeated * 5
        xp += Int(Double(run.ticksSurvived) / 60.0) // 1 XP per second
        if run.didWin {
            xp += 500
        }
        return xp
    }
    
    // Leveling Curve (CUMULATIVE XP model)
    // Returns the TOTAL XP required to reach the NEXT level from the given level.
    // e.g., totalXpRequiredToReachNextLevel(from: 1) = 100 means you need 100 total XP to reach level 2.
    //       totalXpRequiredToReachNextLevel(from: 2) = 400 means you need 400 total XP to reach level 3.
    // Your profile.xp is never reset; it accumulates across all runs.
    public func totalXpRequiredToReachNextLevel(from level: Int) -> Int {
        return 100 * level * level
    }
    
    // Unlocks Check
    public func unlocksForLevel(_ level: Int) -> [String] {
        switch level {
        case 2: return ["relic_uncommon_pack", "tower_sniper"]
        case 3: return ["relic_rare_pack", "tower_missile"]
        case 5: return ["relic_legendary_pack"]
        default: return []
        }
    }
}
